#include <iostream>
#include "poly.h"
using namespace std;

istream& operator>> (istream& is, Polynomial& p) {
    // #terms and (coefficoent, exponent)의 pair들을 읽어들인다.
    // 높은 차수의 항부터 입력되어 저장된다고 가정한다.
    int noofterms; float coef; int exp;
    is >> noofterms;
    for (int i = 0; i < noofterms; i++) {
        is >> coef >> exp; // 계수와 지수 pair를 읽어들인다.
        p.NewTerm(coef, exp);
    }
    return is;
}
ostream& operator<< (ostream& os, Polynomial& p) {
    // 포맷에 맞게 출력하는 코드 입력
    for (int i = 0; i < p.terms; i++)
    {
        if (p.termArray[i].exp > 1) // 지수가 2차 이상이면
        {
            if (p.termArray[i].coef == 1)
                os << "x^" << p.termArray[i].exp;  // 계수가 1이면, "x^지수" 출력
            else if (p.termArray[i].coef == -1)
                os << "-x^" << p.termArray[i].exp;  // 계수가 -1이면, "-x^지수" 출력
            else
                os << p.termArray[i].coef << "x^" << p.termArray[i].exp;  // 그외 계수인 경우, "계수x^지수" 출력
        }
        else if (p.termArray[i].exp == 1)  // 지수가 1차인 경우,
        {
            if (p.termArray[i].coef == 1)
                os << "x";  // 계수가 1이면, "x" 출력
            else if (p.termArray[i].coef == -1)
                os << "-x";  // 계수가 -1이면, "-x" 출력
            else
                os << p.termArray[i].coef << "x";  // 그외 계수인 경우 "계수x" 출력
        }
        else
            os << p.termArray[i].coef;  // 상수항이면 계수만 출력

        if (i < p.terms - 1) { // 마지막 항 전까지
            if (p.termArray[i + 1].coef > 0) {
                os << " +";  // 다음 i+1 항의 계수 값이 양수이면 " +" 출력
            }
            else {
                os << "  ";  // 다음 i+1 항의 계수 값이 음수인 경우 "  " 출력
            }
        }
    }
    os << endl;
    return os;
}

Polynomial::Polynomial() :capacity(1), terms(0)
{
    termArray = new Term[capacity];
}
void Polynomial::NewTerm(const float theCoeff, const int theExp)
{
    // 다항식 뒤에 새로운 항을 추가하는 함수로 교재에 있음
    if (terms == capacity)
    {  // termArray의 크기를 두배로 확장
        capacity *= 2;
        Term* temp = new Term[capacity];  // 새로운 배열
        copy(termArray, termArray + terms, temp);
        delete[] termArray;  // 이전 메모리 반환
        termArray = temp;
    }
    termArray[terms].coef = theCoeff;
    termArray[terms++].exp = theExp;
}
Polynomial Polynomial::operator+(Polynomial& b)
{
    //교재의 Add와 동일한 함수로 이름만 바꾸면 됨
    Polynomial c; // 합 저장
    int aPos = 0, bPos = 0;
    while ((aPos < terms) && (bPos < b.terms))
        if (termArray[aPos].exp == b.termArray[bPos].exp) {
            float t = termArray[aPos].coef + b.termArray[bPos].coef;
            if (t) c.NewTerm(t, termArray[aPos].exp);
            aPos++; bPos++;
        }
        else if (termArray[aPos].exp < b.termArray[bPos].exp) {
            c.NewTerm(b.termArray[bPos].coef, b.termArray[bPos].exp);
            bPos++;
        }
        else {
            c.NewTerm(termArray[aPos].coef, termArray[aPos].exp);
            aPos++;
        }
    // *this의 나머지 항들을 추가한다.
    for (; aPos < terms; aPos++)
        c.NewTerm(termArray[aPos].coef, termArray[aPos].exp);
    // b(x)의 나머지 항들을 추가한다.
    for (; bPos < b.terms; bPos++)
        c.NewTerm(b.termArray[bPos].coef, b.termArray[bPos].exp);
    return c;
}